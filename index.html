<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Walk Overlay</title>
  <style>
    body{
      margin:0;
      background:transparent;
      overflow:hidden;
      font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;
      color:#fff;
    }
    .overlay{
      position:fixed;
      right:4vw;
      bottom:4vh;
      text-align:right;
      pointer-events:none;
    }
    .place{
      font-size:2.4vh;
      font-weight:400;
      letter-spacing:2px;
      text-transform:uppercase;
      text-shadow:0 2px 10px rgba(0,0,0,.7);
      white-space:nowrap;
    }
    .meta{
      margin-top:.25vh;
      font-size:1.6vh;
      font-weight:300;
      opacity:.9;
      text-shadow:0 2px 10px rgba(0,0,0,.7);
      white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="overlay">
    <div class="place" id="place">Locating…</div>
    <div class="meta" id="meta">--°F • --:--:--</div>
  </div>

  <script>
    // --- CONFIG ---
    const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 15000, timeout: 15000 };
    const WEATHER_REFRESH_MS = 300000; // 5 min
    const GEO_REFRESH_MS = 60000;      // 1 min
    const MOVE_EPS = 0.002;            // ~200m-ish in lat/lon

    let lastTempF = "--";
    let lastCoords = null;

    function setText(id, txt){ document.getElementById(id).textContent = txt; }

    function formatTime(){
      return new Date().toLocaleTimeString([], {hour:'numeric', minute:'2-digit', second:'2-digit'});
    }

    function updateMeta(){
      setText("meta", `${lastTempF}°F • ${formatTime()}`);
    }
    setInterval(updateMeta, 1000);

    function isUseful(v){
      return v && typeof v === "string" && v.trim().length > 2 && v.toLowerCase() !== "yes";
    }

    // Reject anything that looks like a street address / house number
    function looksLikeStreetAddress(s){
      if (!isUseful(s)) return false;
      const t = s.trim();

      // starts with house number
      if (/^\d{1,6}\s+\S+/.test(t)) return true;

      // contains common street suffixes
      if (/\b(st|street|rd|road|ave|avenue|blvd|boulevard|dr|drive|ln|lane|ct|court|cir|circle|hwy|highway|pkwy|parkway|trl|trail|way|pl|place)\b/i.test(t)) {
        // paired with a number somewhere is very likely an address
        if (/\d/.test(t)) return true;
      }

      return false;
    }

    function cleanTopFromDisplay(displayName){
      // display_name often starts with a POI or an address; we want the first part ONLY if it's not an address
      if (!isUseful(displayName)) return "";
      const first = displayName.split(",")[0].trim();
      if (!isUseful(first)) return "";
      if (looksLikeStreetAddress(first)) return "";
      return first;
    }

    function pickBestPlace(addr, displayName, namedetails){
      const neighborhood = addr.neighbourhood || addr.neighborhood || "";
      const suburb = addr.suburb || "";
      const city = addr.city || addr.town || addr.village || addr.hamlet || "";
      const state = addr.state || addr.region || "";
      const country = addr.country || "";

      const namedetailName =
        (namedetails && (namedetails.name || namedetails["name:en"])) ?
          (namedetails.name || namedetails["name:en"]) : "";

      // Landmark candidates (many are categories, but sometimes they're actual named POIs)
      const landmarkCandidates = [
        namedetailName,
        addr.attraction,
        addr.tourism,
        addr.leisure,
        addr.park,
        addr.historic,
        addr.natural,
        addr.amenity,
        addr.building,
        cleanTopFromDisplay(displayName),
      ].filter(isUseful);

      // Choose first landmark candidate that does NOT look like an address
      let landmark = "";
      for (const c of landmarkCandidates) {
        if (!looksLikeStreetAddress(c)) { landmark = c; break; }
      }

      // If we didn't get a landmark, fall back to locality (never show house number/road)
      const local = isUseful(landmark) ? landmark
                  : (isUseful(neighborhood) ? neighborhood
                  : (isUseful(suburb) ? suburb
                  : (isUseful(city) ? city
                  : (isUseful(state) ? state
                  : (isUseful(country) ? country : "Your Location")))));

      // Anchor it cleanly:
      // - If local is neighborhood/suburb/landmark, anchor with "City, State" when possible
      // - If local is City, anchor with State
      // - If local is State, don't add country
      if (isUseful(state) && local === state) return state;

      let anchor = "";
      if (isUseful(city) && local !== city) {
        anchor = isUseful(state) ? `${city}, ${state}` : city;
      } else if (isUseful(state) && local !== state) {
        anchor = state;
      }

      // If anchor would redundantly repeat local, skip it
      if (anchor && anchor !== local) return `${local}, ${anchor}`;
      return local;
    }

    async function reverseGeocode(lat, lon){
      // namedetails/extratags can help; zoom=18 is a good “place” level
      const url =
        `https://nominatim.openstreetmap.org/reverse` +
        `?format=jsonv2&lat=${lat}&lon=${lon}` +
        `&zoom=18&addressdetails=1&namedetails=1&extratags=1`;

      const res = await fetch(url, { headers: { "Accept": "application/json" }});
      if (!res.ok) throw new Error("geocode failed");
      const data = await res.json();
      return pickBestPlace(data.address || {}, data.display_name || "", data.namedetails || {});
    }

    async function fetchWeather(lat, lon){
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&temperature_unit=fahrenheit`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("weather failed");
      const data = await res.json();
      const t = Math.round(data.current_weather?.temperature);
      if (Number.isFinite(t)) lastTempF = t;
      updateMeta();
    }

    async function refreshAll(lat, lon){
      const movedEnough = !lastCoords
        || Math.abs(lat - lastCoords.lat) > MOVE_EPS
        || Math.abs(lon - lastCoords.lon) > MOVE_EPS;

      lastCoords = {lat, lon};

      fetchWeather(lat, lon).catch(()=>{ lastTempF="--"; updateMeta(); });

      if (movedEnough){
        reverseGeocode(lat, lon)
          .then(place => setText("place", place))
          .catch(() => setText("place", "Location"));
      }
    }

    function startGeolocation(){
      if (!navigator.geolocation){
        setText("place", "No GPS");
        return;
      }

      const onPos = (pos) => refreshAll(pos.coords.latitude, pos.coords.longitude);
      const onErr = () => setText("place", "Enable Location");

      navigator.geolocation.getCurrentPosition(onPos, onErr, GEO_OPTIONS);
      setInterval(() => navigator.geolocation.getCurrentPosition(onPos, onErr, GEO_OPTIONS), GEO_REFRESH_MS);
    }

    updateMeta();
    startGeolocation();

    setInterval(() => {
      if (lastCoords) fetchWeather(lastCoords.lat, lastCoords.lon).catch(()=>{});
    }, WEATHER_REFRESH_MS);
  </script>
</body>
</html>
