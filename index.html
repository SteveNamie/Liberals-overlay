<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Walk Overlay</title>

  <style>
    body{
      margin:0;
      background:transparent;
      overflow:hidden;
      font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;
      color:#fff;
    }
    .overlay{
      position:fixed;
      right:4vw;
      bottom:4vh;
      text-align:right;
      pointer-events:none;
    }
    .place{
      font-size:2.4vh;
      font-weight:400;
      letter-spacing:2px;
      text-transform:uppercase;
      text-shadow:0 2px 10px rgba(0,0,0,.7);
      white-space:nowrap;
      line-height:1.15;
    }
    .meta{
      margin-top:.25vh;
      font-size:1.6vh;
      font-weight:300;
      opacity:.95;
      text-shadow:0 2px 10px rgba(0,0,0,.7);
      white-space:nowrap;
      display:flex;
      gap:.7vh;
      justify-content:flex-end;
      align-items:center;
    }

    /* subtle blinking divider dot (broadcast feel) */
    .dot{
      display:inline-block;
      width:.55vh;
      height:.55vh;
      border-radius:999px;
      background:rgba(255,255,255,.95);
      box-shadow:0 0 10px rgba(255,255,255,.25);
      animation:dotPulse 2.2s ease-in-out infinite;
      transform:translateY(.05vh);
    }
    @keyframes dotPulse{
      0%   { opacity:.25; transform:translateY(.05vh) scale(.92); }
      50%  { opacity:1;   transform:translateY(.05vh) scale(1.00); }
      100% { opacity:.25; transform:translateY(.05vh) scale(.92); }
    }
  </style>
</head>

<body>
  <div class="overlay">
    <!-- Line 1: landmark/park/neighborhood (only shown when available) -->
    <div class="place" id="placeTop" style="display:none;">Locating…</div>

    <!-- Line 2: city, state (always shown once we can resolve) -->
    <div class="place" id="place">Locating…</div>

    <!-- Line 3: temp + blinking dot + time -->
    <div class="meta">
      <span id="temp">--°F</span>
      <span class="dot" aria-hidden="true"></span>
      <span id="time">--:--:--</span>
    </div>
  </div>

  <script>
    // --- CONFIG ---
    const GEO_OPTIONS = { enableHighAccuracy: true, maximumAge: 15000, timeout: 15000 };
    const WEATHER_REFRESH_MS = 300000; // 5 min
    const GEO_REFRESH_MS = 60000;      // 1 min
    const MOVE_EPS = 0.001;            // ~100m (more responsive for neighborhoods)

    let lastTempF = "--";
    let lastCoords = null;

    function setPlaceLines(topLine, cityStateLine){
      const topEl = document.getElementById("placeTop");
      const cityEl = document.getElementById("place");

      if (topLine && topLine.trim()){
        topEl.style.display = "block";
        topEl.textContent = topLine;
      } else {
        topEl.style.display = "none";
        topEl.textContent = "";
      }
      cityEl.textContent = (cityStateLine && cityStateLine.trim()) ? cityStateLine : "Location";
    }

    function formatTime(){
      return new Date().toLocaleTimeString([], {hour:'numeric', minute:'2-digit', second:'2-digit'});
    }
    function updateTime(){
      document.getElementById("time").textContent = formatTime();
    }
    setInterval(updateTime, 1000);
    updateTime();

    // Never show street addresses as “neighborhood”
    function looksLikeStreetAddress(s){
      if (!s || typeof s !== "string") return false;
      const t = s.trim();
      if (!t) return false;
      if (/^\d{1,6}\s+\S+/.test(t)) return true; // starts with house number
      if (/\b(st|street|rd|road|ave|avenue|blvd|boulevard|dr|drive|ln|lane|ct|court|cir|circle|hwy|highway|pkwy|parkway|trl|trail|way|pl|place)\b/i.test(t) && /\d/.test(t)) {
        return true;
      }
      return false;
    }

    function bestFeature(addr){
      return (
        addr.national_park ||
        addr.park ||
        addr.protected_area ||
        addr.nature_reserve ||
        addr.attraction ||
        addr.tourism ||
        addr.leisure ||
        addr.historic ||
        addr.natural ||
        addr.museum ||
        addr.zoo ||
        ""
      );
    }

    function bestNeighborhood(addr){
      // Neighborhood/district-ish fields vary a lot by region and data completeness
      const n = (
        addr.neighbourhood || addr.neighborhood ||
        addr.quarter ||
        addr.suburb ||
        addr.city_district ||
        addr.borough ||
        addr.district ||
        ""
      );
      return looksLikeStreetAddress(n) ? "" : n;
    }

    function getCity(addr){
      return addr.city || addr.town || addr.village || addr.hamlet || "";
    }

    function getState(addr){
      return addr.state || addr.region || "";
    }

    function cityStateLine(addrA, addrB){
      const city = getCity(addrB) || getCity(addrA);
      const state = getState(addrB) || getState(addrA);
      const country = (addrB && addrB.country) || (addrA && addrA.country) || "";

      if (city && state) return `${city}, ${state}`;
      if (city) return city;
      if (state) return state;           // never show "State, Country"
      return country || "Your Location";
    }

    function mergePlaceLines(addr14, addr18){
      const feature = bestFeature(addr18) || bestFeature(addr14);
      const hood = bestNeighborhood(addr14) || bestNeighborhood(addr18);

      let topLine = feature || hood || "";
      const line2 = cityStateLine(addr14, addr18);

      // avoid repeating line2
      if (topLine && topLine === line2) topLine = "";

      return { topLine, cityStateLine: line2 };
    }

    async function reverseGeocode(lat, lon, zoom){
      // Note: We read only "address" fields; no display_name usage (prevents house # showing up)
      const url =
        `https://nominatim.openstreetmap.org/reverse?format=jsonv2` +
        `&lat=${lat}&lon=${lon}&zoom=${zoom}&addressdetails=1&namedetails=1&extratags=1`;

      const res = await fetch(url, { headers: { "Accept": "application/json" }});
      if (!res.ok) throw new Error("geocode failed");
      const data = await res.json();
      return data.address || {};
    }

    async function resolvePlace(lat, lon){
      // two-pass: zoom 14 for districts/neighborhoods, zoom 18 for parks/POIs
      const [a14, a18] = await Promise.all([
        reverseGeocode(lat, lon, 14),
        reverseGeocode(lat, lon, 18)
      ]);
      return mergePlaceLines(a14, a18);
    }

    async function fetchWeather(lat, lon){
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&temperature_unit=fahrenheit`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("weather failed");
      const data = await res.json();
      const t = Math.round(data.current_weather?.temperature);
      if (Number.isFinite(t)) lastTempF = t;
      document.getElementById("temp").textContent = `${lastTempF}°F`;
    }

    async function refreshAll(lat, lon){
      const movedEnough = !lastCoords
        || Math.abs(lat - lastCoords.lat) > MOVE_EPS
        || Math.abs(lon - lastCoords.lon) > MOVE_EPS;

      lastCoords = {lat, lon};

      // weather every time
      fetchWeather(lat, lon).catch(()=>{ document.getElementById("temp").textContent = "--°F"; });

      // place only when moved enough
      if (movedEnough){
        resolvePlace(lat, lon)
          .then(({topLine, cityStateLine}) => setPlaceLines(topLine, cityStateLine))
          .catch(() => setPlaceLines("", "Location"));
      }
    }

    function startGeolocation(){
      if (!navigator.geolocation){
        setPlaceLines("", "No GPS");
        return;
      }

      const onPos = (pos) => refreshAll(pos.coords.latitude, pos.coords.longitude);
      const onErr = () => setPlaceLines("", "Enable Location");

      navigator.geolocation.getCurrentPosition(onPos, onErr, GEO_OPTIONS);
      setInterval(() => navigator.geolocation.getCurrentPosition(onPos, onErr, GEO_OPTIONS), GEO_REFRESH_MS);
    }

    startGeolocation();

    // refresh weather periodically even if you aren’t moving
    setInterval(() => {
      if (lastCoords) fetchWeather(lastCoords.lat, lastCoords.lon).catch(()=>{});
    }, WEATHER_REFRESH_MS);
  </script>
</body>
</html>
