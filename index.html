<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Live Walk Overlay</title>

<style>
body{
  margin:0;
  background:transparent;
  overflow:hidden;
  font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;
  color:#fff;
}

.overlay{
  position:fixed;
  right:4vw;
  bottom:4vh;
  text-align:right;
  pointer-events:none;
}

.place{
  font-size:4.2vh;
  font-weight:400;
  letter-spacing:3px;
  text-transform:uppercase;
  text-shadow:0 2px 10px rgba(0,0,0,.7);
  white-space:nowrap;
  line-height:1.15;
}

.meta{
  margin-top:.25vh;
  font-size:2.6vh;
  font-weight:300;
  opacity:.9;
  text-shadow:0 2px 10px rgba(0,0,0,.7);
  white-space:nowrap;
}

.dot{
  animation:blink 2s infinite;
}

@keyframes blink{
  0%{opacity:.2;}
  50%{opacity:1;}
  100%{opacity:.2;}
}
</style>
</head>

<body>

<div class="overlay">

<div class="place" id="placeTop" style="display:none;"></div>

<div class="place" id="place">Locating…</div>

<div class="meta" id="meta">
--°F <span class="dot">•</span> --:--:--
</div>

</div>

<script>

const GEO_OPTIONS = {
enableHighAccuracy:true,
maximumAge:15000,
timeout:15000
};

const WEATHER_REFRESH_MS = 300000;
const GEO_REFRESH_MS = 60000;

let lastTempF="--";
let lastCoords=null;

function setText(id,txt){
document.getElementById(id).textContent=txt;
}

function formatTime(){
return new Date().toLocaleTimeString([],{
hour:'numeric',
minute:'2-digit',
second:'2-digit'
});
}

function updateMeta(){
document.getElementById("meta").innerHTML=
`${lastTempF}°F <span class="dot">•</span> ${formatTime()}`;
}

setInterval(updateMeta,1000);

function normalizeState(state){
return state||"";
}

function setPlaceLines(topLine,cityStateLine){

const topEl=document.getElementById("placeTop");
const cityEl=document.getElementById("place");

if(topLine && topLine.trim()){
topEl.style.display="block";
topEl.textContent=topLine;
}else{
topEl.style.display="none";
topEl.textContent="";
}

cityEl.textContent=
cityStateLine && cityStateLine.trim()
? cityStateLine
: "Location";
}

function pickBestPlaceLines(addr){

const feature=
addr.national_park||
addr.park||
addr.protected_area||
addr.nature_reserve||
addr.attraction||
addr.leisure||
addr.tourism||
addr.natural||
addr.museum||
addr.zoo||
addr.aerodrome||
"";

const neighborhood=
addr.neighbourhood||
addr.neighborhood||
addr.quarter||
"";

const district=
addr.suburb||
addr.city_district||
addr.borough||
addr.district||
"";

const city=
addr.city||
addr.town||
addr.village||
addr.hamlet||
"";

const state=
normalizeState(addr.state||addr.region||"");

const country=
addr.country||"";

const topLine=
feature || neighborhood || district || "";

let cityState="";

if(city && state)
cityState=`${city}, ${state}`;
else if(city)
cityState=city;
else if(state && country)
cityState=`${state}, ${country}`;
else
cityState=country || "Location";

const topClean=
(topLine && (topLine===city || topLine===state))
? ""
: topLine;

return {
topLine:topClean,
cityStateLine:cityState
};
}

async function reverseGeocode(lat,lon,zoom){

const url=
`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=${zoom}&addressdetails=1`;

const res=await fetch(url);

if(!res.ok)
throw new Error("geocode failed");

const data=await res.json();

return data.address||{};
}

async function fetchPlace(lat,lon){

try{

const addr1=await reverseGeocode(lat,lon,18);
const result1=pickBestPlaceLines(addr1);

if(result1.topLine)
return result1;

const addr2=await reverseGeocode(lat,lon,14);
return pickBestPlaceLines(addr2);

}catch{

return {topLine:"",cityStateLine:"Location"};

}

}

async function fetchWeather(lat,lon){

try{

const url=
`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&temperature_unit=fahrenheit`;

const res=await fetch(url);

const data=await res.json();

const t=Math.round(data.current_weather?.temperature);

if(Number.isFinite(t))
lastTempF=t;

}catch{}

updateMeta();

}

async function refreshAll(lat,lon){

const movedEnough=
!lastCoords ||
Math.abs(lat-lastCoords.lat)>.002 ||
Math.abs(lon-lastCoords.lon)>.002;

lastCoords={lat,lon};

fetchWeather(lat,lon);

if(movedEnough){

fetchPlace(lat,lon)
.then(({topLine,cityStateLine})=>{
setPlaceLines(topLine,cityStateLine);
})
.catch(()=>setPlaceLines("", "Location"));

}

}

function startGeolocation(){

if(!navigator.geolocation){

setPlaceLines("", "No GPS");

return;

}

const onPos=(pos)=>{

const lat=pos.coords.latitude;
const lon=pos.coords.longitude;

refreshAll(lat,lon);

};

const onErr=()=>{

setPlaceLines("", "Enable Location");

};

navigator.geolocation.getCurrentPosition(onPos,onErr,GEO_OPTIONS);

setInterval(()=>{
navigator.geolocation.getCurrentPosition(onPos,onErr,GEO_OPTIONS);
},GEO_REFRESH_MS);

}

updateMeta();

startGeolocation();

setInterval(()=>{

if(lastCoords)
fetchWeather(lastCoords.lat,lastCoords.lon);

},WEATHER_REFRESH_MS);

</script>

</body>
</html>
