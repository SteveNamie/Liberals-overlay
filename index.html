<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Live Walk Overlay</title>

<style>
body{
margin:0;
background:transparent;
overflow:hidden;
font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;
color:#fff;
}

.overlay{
position:fixed;
right:4vw;
bottom:4vh;
text-align:right;
pointer-events:none;
}

.place{
font-size:2.9vh;   /* increased from previous */
font-weight:400;
letter-spacing:2px;
text-transform:uppercase;
text-shadow:0 2px 10px rgba(0,0,0,.7);
white-space:nowrap;
line-height:1.15;
opacity:1;
transition:opacity .55s ease;
}

.meta{
margin-top:.25vh;
font-size:2.2vh;   /* increased from previous */
font-weight:300;
opacity:.9;
text-shadow:0 2px 10px rgba(0,0,0,.7);
white-space:nowrap;
transition:opacity .55s ease;
}

.dot{
display:inline-block;
margin:0 .35em;
animation:dotFade 4s ease-in-out infinite;
}

@keyframes dotFade{
0%{opacity:.2;}
50%{opacity:1;}
100%{opacity:.2;}
}

.fadeOut{
opacity:0;
}
</style>
</head>

<body>

<div class="overlay">

<div class="place" id="placeTop" style="display:none;">Locating…</div>

<div class="place" id="place">Locating…</div>

<div class="meta" id="meta">
--°F <span class="dot">•</span> --:--:--
</div>

</div>

<script>

const GEO_OPTIONS={enableHighAccuracy:true,maximumAge:15000,timeout:15000};
const WEATHER_REFRESH_MS=300000;
const GEO_REFRESH_MS=60000;

let lastTempF="--";
let lastCoords=null;

let lastTopText="";
let lastMainText="";

function formatTime(){
return new Date().toLocaleTimeString([],{
hour:'numeric',
minute:'2-digit',
second:'2-digit'
});
}

function updateMeta(){
document.getElementById("meta").innerHTML=
`${lastTempF}°F <span class="dot">•</span> ${formatTime()}`;
}

setInterval(updateMeta,1000);

function normalizeState(state){
return state||"";
}

function setPlaceVisibility(topLine){
const topEl=document.getElementById("placeTop");
if(topLine && topLine.trim()){
topEl.style.display="block";
}else{
topEl.style.display="none";
}
}

function setPlaceLinesSmooth(topLine,cityStateLine){

const topEl=document.getElementById("placeTop");
const mainEl=document.getElementById("place");

const newTop=(topLine||"").trim();
const newMain=(cityStateLine||"Location").trim();

if(newTop===lastTopText && newMain===lastMainText) return;

lastTopText=newTop;
lastMainText=newMain;

setPlaceVisibility(newTop);

topEl.classList.add("fadeOut");
mainEl.classList.add("fadeOut");

setTimeout(()=>{

topEl.textContent=newTop||"";
mainEl.textContent=newMain;

setPlaceVisibility(newTop);

setTimeout(()=>{
topEl.classList.remove("fadeOut");
mainEl.classList.remove("fadeOut");
},40);

},260);
}

function pickBestPlaceLines(addr){

const feature=
addr.national_park||
addr.park||
addr.protected_area||
addr.nature_reserve||
addr.attraction||
addr.leisure||
addr.tourism||
addr.natural||
addr.museum||
addr.zoo||
addr.aerodrome||
"";

const neighborhood=
addr.neighbourhood||
addr.neighborhood||
addr.quarter||
"";

const district=
addr.suburb||
addr.city_district||
addr.borough||
addr.district||
"";

const city=
addr.city||
addr.town||
addr.village||
addr.hamlet||
"";

const state=normalizeState(addr.state||addr.region||"");
const country=addr.country||"";

const topLine=feature||neighborhood||district||"";

let cityState="";
if(city && state) cityState=`${city}, ${state}`;
else if(city) cityState=city;
else if(state && country) cityState=`${state}, ${country}`;
else cityState=country||"Your Location";

const topClean=(topLine && (topLine===city || topLine===state))?"":topLine;

return{topLine:topClean,cityStateLine:cityState};
}

async function reverseGeocode(lat,lon){

const url=`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=16&addressdetails=1`;

const res=await fetch(url,{headers:{"Accept":"application/json"}});
if(!res.ok) throw new Error("geocode failed");

const data=await res.json();
const addr=data.address||{};

return pickBestPlaceLines(addr);
}

async function fetchWeather(lat,lon){

const url=`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&temperature_unit=fahrenheit`;

const res=await fetch(url);
if(!res.ok) throw new Error("weather failed");

const data=await res.json();

const t=Math.round(data.current_weather?.temperature);
if(Number.isFinite(t)) lastTempF=t;

updateMeta();
}

async function refreshAll(lat,lon){

const movedEnough=!lastCoords||
Math.abs(lat-lastCoords.lat)>0.002||
Math.abs(lon-lastCoords.lon)>0.002;

lastCoords={lat,lon};

fetchWeather(lat,lon).catch(()=>{
lastTempF="--";
updateMeta();
});

if(movedEnough){
reverseGeocode(lat,lon)
.then(({topLine,cityStateLine})=>{
setPlaceLinesSmooth(topLine,cityStateLine);
})
.catch(()=>{
setPlaceLinesSmooth("","Location");
});
}
}

function startGeolocation(){

if(!navigator.geolocation){
setPlaceLinesSmooth("","No GPS");
return;
}

const onPos=(pos)=>{
const lat=pos.coords.latitude;
const lon=pos.coords.longitude;
refreshAll(lat,lon);
};

const onErr=()=>{
setPlaceLinesSmooth("","Enable Location");
};

navigator.geolocation.getCurrentPosition(onPos,onErr,GEO_OPTIONS);

setInterval(()=>{
navigator.geolocation.getCurrentPosition(onPos,onErr,GEO_OPTIONS);
},GEO_REFRESH_MS);
}

updateMeta();
startGeolocation();

setInterval(()=>{
if(lastCoords){
fetchWeather(lastCoords.lat,lastCoords.lon).catch(()=>{});
}
},WEATHER_REFRESH_MS);

</script>
</body>
</html>
